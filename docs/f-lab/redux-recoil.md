---
title: 'redux-recoil'
description: ''
date: 2024-11-10
update: 2024-11-10
tags:
  - 상태관리
  - Redux
  - Recoil
series: 'React'
---

Redux의 액션(action), 리듀서(reducer), 미들웨어(middleware) 구조와 Recoil의 Atom, Selector 개념을 비교하여 각 라이브러리가 상태 관리와 비동기 처리를 어떻게 처리하는지 설명해주세요.

Redux의 전형적인 패턴(액션, 리듀서, 미들웨어)과 Recoil의 간결한 상태 관리 방식(Atom, Selector)을 설명하고, 상태 관리와 비동기 처리를 어떻게 처리하는지 확인합니다.

---

## Redux

Action Redux의 액션은 상태에 변화를 일으키기 위한 의도를 표현합니다. 액션은 type과 필요한 데이터를 담은 객체 형식으로 작성됩니다. 상태 변경을 일으키기 위해 액션 생성자(action creator)를 사용하여 액션 객체를 생성한 뒤, 이를 dispatch로 리듀서에 전달하여 상태가 변하게 됩니다.

Reducer 리듀서는 순수 함수로, 이전 상태와 액션을 입력받아 새로운 상태를 반환합니다. 모든 상태 변경 로직은 리듀서 내부에 위치하며, 액션 타입에 따라 조건문 또는 스위치 문으로 분기합니다.

- 단방향 데이터 흐름: Redux는 단방향 데이터 흐름을 따릅니다. 즉, 액션을 dispatch하여 리듀서가 상태를 업데이트한 후 새 상태가 컴포넌트로 전달됩니다. 이 일관된 흐름 덕분에 상태 관리가 예측 가능하고 디버깅이 용이해집니다.

- 상태 불변성 유지: 리듀서가 상태를 변경할 때는 기존 상태의 불변성을 유지해야 합니다. 직접 상태를 수정하지 않고 새로운 객체를 반환하는 방식으로 상태를 업데이트합니다. 예를 들어, Object.assign이나 스프레드 연산자를 사용하여 상태를 복사한 후 변경된 부분만 반영합니다. Redux Toolkit의 createSlice는 불변성 관리를 자동으로 도와줘서, 상태를 더 쉽게 관리할 수 있게 합니다.

- Middleware Redux 미들웨어는 액션이 리듀서에 도달하기 전에 가로채어 추가 작업을 수행할 수 있도록 합니다. 대표적으로 Redux Thunk와 Redux Saga가 있으며, 비동기 처리를 위해 자주 사용됩니다.

- Redux Thunk는 함수 형태의 액션을 통해 비동기 로직을 실행하고,
  Redux Saga는 제너레이터 함수를 통해 비동기 흐름을 보다 명확하게 관리할 수 있게 합니다.

상태 관리 및 비동기 처리 상태는 스토어에서 중앙 집중적으로 관리되며, 액션 디스패치를 통해 상태가 변경됩니다. 비동기 처리는 미들웨어에서 처리하며, 비동기 로직이 끝난 후 적절한 액션을 디스패치하여 상태를 업데이트합니다.

## Recoil

Atom Recoil의 아톰(Atom)은 상태의 최소 단위로, 각각 독립적인 상태 조각입니다. React 컴포넌트는 아톰을 구독하며 해당 아톰이 업데이트되면 자동으로 다시 렌더링됩니다. Redux와 달리, Recoil은 여러 아톰을 통해 분산된 상태 관리가 가능합니다.

Selector 셀렉터(Selector)는 파생된 상태(derived state)를 생성하는 도구입니다. 다른 아톰이나 셀렉터의 값을 입력받아 동기 또는 비동기적으로 계산된 새로운 값을 반환합니다.

비동기 셀렉터를 통해 서버에서 데이터를 가져오는 등의 비동기 작업을 수행할 수 있습니다. Recoil은 비동기 셀렉터의 Promise 상태를 자동으로 관리하여 로딩, 성공, 실패를 처리할 수 있습니다.

상태 관리 및 비동기 처리 상태는 아톰을 통해 컴포넌트 단위로 관리되며, 아톰의 변화를 감지하여 자동으로 컴포넌트가 리렌더링됩니다. 비동기 처리는 주로 셀렉터에서 이루어지며, 비동기 셀렉터가 Promise를 반환하면 Recoil이 해당 상태의 로딩 및 에러를 자동으로 관리합니다
